---
title: "Spatial Transcriptomics"
subtitle: "CSAMA 2024 Version"
author:
    - name: Davide Risso
      affiliation: 
        - Department of Statistical Sciences, University of Padova, Padova, Italy
date: "11 June 2024"
bibliography: biblio.bib
output: BiocStyle::html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE, error = FALSE, message = FALSE,
                      warning = FALSE, echo = TRUE, results = "markup",
                      fig.align = "center", collapse = TRUE)
```

# Introduction

In this tutorial we walk through a typical spatial transcriptomics analysis using Bioconductor packages.

Spatial transcriptomics is a fast evolving set of technologies and we cannot cover all protocols here. However, we will show an example of spot-based protocols, namely 10X Genomics Visium, and an example of imaging-based methods, namely Nanostring CosMX. Note that this is an area of current development and some methods will likely be improved in the next months. 

Most of the steps covered here, especially those for spot-based data, are described in the [Best Practices ST](https://lmweber.org/BestPracticesST/) book.

The [Voyager](https://pachterlab.github.io/voyager/) Bioconductor package [@Moses2023] also has an extensive set of tutorials that cover most of the currently available spatial transcriptomics technologies.

While not covered in this tutorial, there are packages and software tools for the analysis of spatial transcriptomics data outside of Bioconductor too. Popular tools include the [Seurat R package](https://satijalab.org/seurat/), the [Giotto R package](https://giottosuite.readthedocs.io/en/latest/index.html) and the [SpatialData python package](https://spatialdata.scverse.org/en/latest/).

# Visium Data

We will initially focus on 10X Genomics Visium. We start from the output of the Space Ranger preprocessing software. This is the 10X Genomics software suite that allows to pre-process the FASTQ files generated by the sequencing platform and perform alignment and quantification. We will perform exploratory data analysis (EDA) and quality control (QC). We will then cover normalization, the identification of spatially variable genes dimensionality reduction and cell type identification and .

## Experimental data

We will use one sample of human brain from the dorsolateral prefrontal cortex (DLPFC) region, measured using the 10x Genomics Visium platform.

In the full dataset, there are 12 samples in total, from 3 individuals, with 2 pairs of spatially adjacent replicates (serial sections) per individual (4 samples per individual). The individuals and spatially adjacent replicates can be used as blocking factors. Each sample spans the six layers of the cortex plus white matter in a perpendicular tissue section. For the examples in this workflow we use a single sample from this dataset (sample 151673).

For more details on the dataset, see @maynard2021transcriptome. The full dataset is publicly available through the [spatialLIBD Bioconductor package](https://bioconductor.org/packages/spatialLIBD/).

## The SpatialExperiment class

`SpatialExperiment` is a S4 class that _extends_ `SingleCellExperiment` and can be used for efficiently storing and working with spatial data in R/Bioconductor.

This class is itself extended by `MoleculeExperiment` and `SpatialFeatureExperiment`, which allow to more easily work with imaging-based data. For the moment, we will use `SpatialExperiment`.

```{r spe-class, results="asis", out.width="100%", echo=FALSE}
knitr::include_graphics("img/SpatialExperiment.png")
```

A more thorough overview of `SingleCellExperiment` can be found in @righelli2022spatialexperiment.

We start by loading the data.

```{r spe-obj}
library(SpatialExperiment)
library(STexampleData)
spe <- Visium_humanDLPFC()
spe
```
The `SpatialExperiment` class should be fairly familiar, since it is heavily based on the `SingleCellExperiment` class. In addition to the slots that you already know, a `SpatialExperiment` object includes the `spatialCoords` and the `imgData` slots.

```{r spatialcoords}
head(spatialCoords(spe))
imgData(spe)
```
Note that the `colData` `DataFrame` is still where most of the useful information about the spots are available.

```{r coldata}
colData(spe)
```

In this case, we have a ground truth annotation of the spots, as well as an indication of the number of cells covered by each spots.

## Visualization

One nice feature of spatial transcriptomics is that we can "see" the tissue under study and visualize the spots on top of the histology image. We will use the ``ggspavis` package to do so.

```{r plotvisium}
library(ggspavis)

plotVisium(spe)
```

We can also visualize the ground truth annotation of the spots.

```{r plotlayer}
plotSpots(spe, annotate = "ground_truth", 
          pal = "libd_layer_colors")
```

We can see that, while the Visium platform consists of a grid of spots, only some of them will be covered by the tissue: these are called "in_tissue" in SpatialExperiment.

```{r intissue}
spe$in_tissue <- as.factor(spe$in_tissue)
plotSpots(spe, in_tissue = NULL, annotate = "in_tissue")
```

For the rest of the workflow, we will only keep the in-tissue spots.

```{r filt-intissue}
spe <- spe[, colData(spe)$in_tissue == 1]
```

## Quality control and normalization

Spot-based spatial transcriptomics is based on short-read sequencing of RNA molecules and as such many methods originally developed for single-cell RNA-seq can be used to analyze Visium data.

In particular, scater's `perCellQCMetrics` function can be used to compute a set of metrics useful to evaluate the quality of the samples. The `isOutlier` function uses a data driven threshold to define cells of lower quality compared to the rest of the dataset.

Similarly to what we have done in the single-cell workflow, it is useful to identify spots with high percentages of mitochondrial reads, which may be a symptom of poor sample quality. 

```{r}
library(EnsDb.Hsapiens.v86)
rowData(spe)$location <- mapIds(EnsDb.Hsapiens.v86,
                                     keys=rowData(spe)$gene_id, 
                                     column="SEQNAME", keytype="GENEID")
table(rowData(spe)$location=="MT")
```

We can now compute the QC metrics with scater.

```{r scater-qc}
library(scater)
spe <- addPerCellQC(spe, subsets = list(mito = which(rowData(spe)$location=="MT")))
colData(spe)
```

We can visualize the metrics and compute data-driven thresholds to flag low-quality cells.

```{r outlier}
hist(spe$subsets_mito_percent)
high.mito <- isOutlier(spe$subsets_mito_percent, type="higher")
table(high.mito)
hist(spe$sum)
low.umi <- isOutlier(spe$sum, type="lower")
table(low.umi)
```


In this case, only a few spots are discarded for high mitochondrial content. We can check whether there are spatial patterns of low quality.

```{r plot-mito}
colData(spe)$high.mito <- high.mito
plotSpotQC(spe, plot_type = "spot", 
           annotate = "high.mito")
```

We can plot the library sizes against the number of cells per spot (which is available for this dataset). We expect that spots with more cells will tend to have a higher number of UMIs.

```{r plotqc}
plotSpotQC(spe, plot_type = "scatter", 
           x_metric = "cell_count", y_metric = "sum")
```
We see that the spots with very high cell counts also have low numbers of expressed genes. This indicates that the experiments have failed for these spots, and they should be removed. We select a threshold of 10 cells per spot. The number of spots above this threshold is relatively small, and there is a clear downward trend in the number of expressed genes above this threshold.

```{r plotnum}
high.cellcount <- colData(spe)$cell_count > 10
table(high.cellcount)
spe$high.cellcount <- high.cellcount
plotSpotQC(spe, plot_type = "spot", 
           annotate = "high.cellcount")
```
The discarded spots are all on the edges of the tissue. It seems plausible that something has gone wrong with the cell segmentation on the edges of the images, so it makes sense to remove these spots.

Since only a small number of spots are flagged as low quality, we can leave them in the object and simply flag them as low-quality.

```{r filter-spots}
table(high.cellcount | high.mito)
low_quality <- which(high.cellcount | high.mito)
```

As for quality control, normalization can be borrowed from the single-cell literature. Published work use simple methods, such as the library size normalization. We use here this simple strategy, but more advanced methods can be used (see the single-cell workflow).

```{r norm}
spe <- logNormCounts(spe)
spe
```
**Exercise**: Use the `scran` package to normalize the data with the pool deconvolution method and compare the size factors with the library sizes.

# Spatially variable genes

In a typical single-cell analysis, we focus on the highly variable genes in the hope that they will carry most of the biological information. Spatial transcriptomics allows us to identify _spatially variable genes_ (SVGs), i.e., genes with spatially correlated patterns of expression across the tissue area.

Several methods to identify SVGs in ST data have recently been developed; here we focus on the [nnSVG method](	https://bioconductor.org/packages/nnSVG/) [@weber2023nnsvg].

In this example, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset by subsampling on the set of spots and including stringent filtering for low-expressed genes. A full analysis using all spots for this dataset and default filtering parameters for Visium data from human brain tissue takes around 45 minutes for one Visium sample on a standard laptop.

```{r nnsvg}
library(nnSVG)

n <- 100
set.seed(123)
ix <- sample(seq_len(n), n)
spe_nnSVG <- spe[, ix]

spe_nnSVG <- filter_genes(
  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3
)
spe_nnSVG <- logNormCounts(spe_nnSVG)

spe_nnSVG <- nnSVG(spe_nnSVG)
head(rowData(spe_nnSVG), 3)
```
We can for instance inspect the top SVGs by ordering by the `rank` column.

```{r nnsvg-rank}
rowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank),]
```

These results already offer a way to explore potentially interesting spatial signal, e.g., by plotting the expression pattern of the top ranked genes.

```{r plot-genes}
plotSpots(spe, annotate = "ENSG00000197971")
```

# Dimensionality reduction

We now apply principal component analysis (PCA) to reduce the dimensionality of the dataset, and retain the top 50 principal components (PCs) for further downstream analyses.

This is done for two reasons: (i) to reduce noise due to random variation in expression of biologically uninteresting genes, which are assumed to have expression patterns that are independent of each other, and (ii) to improve computational efficiency during downstream analyses.

Here we use scater's implementation of PCA that by default uses the top 500 most variable genes, but one can specify to use SVGs instead, e.g., by running `nnSVG` on the full dataset and select the top 500 or 1000 SVGs.

We will also visualize the data in a UMAP plot.

```{r pca}
spe <- runPCA(spe)
spe <- runUMAP(spe)

plotPCA(spe, colour_by = "ground_truth")
plotUMAP(spe, colour_by = "ground_truth")
```

Again, one advantage of spatial transcriptomics is the ability of visualizing gene expression (in this case the top PCs) in the space of the original tissue. Here, we visualize the top two PCs.

```{r plot-spot-pc}
spe$PC1 <- reducedDim(spe)[,1]
spe$PC2 <- reducedDim(spe)[,2]
plotSpots(spe, annotate = "PC1")
plotSpots(spe, annotate = "PC2")
```

# Spatially-aware clustering

It is natural to think that spots that are physically close in tissue's space will be more likely to be of the same type (e.g., represent a morphological distinct spatial domain).

This is the main idea behind `BayesSpace` [@zhao2021spatial], which uses a Bayesian Pott's model to cluster spots.

Here, we specify seven clusters becaue we know from the ground truth labels that we should expect seven areas in the tissue. The `BayesSpace` package vignette describes a more general worklfow to use when the number of clusters is unknown.

For computational reasons we run this analysis with only 1000 iterations, but in real analyses at least 10,000 are needed.

```{r bayespace}
library(BayesSpace)

spe_bay <- as(spe, "SingleCellExperiment")
spe_bay$row <- spe_bay$array_row
spe_bay$col <- spe_bay$array_col

set.seed(1650)

spe_bay <- spatialPreprocess(spe_bay, platform="Visium", 
                              n.PCs=10, n.HVGs=1000)

spe_bay <- spatialCluster(spe_bay, q=7, platform="Visium", d=10,
                           init.method="mclust", model="t", gamma=2,
                           nrep=1000, burn.in=100,
                           save.chain=TRUE)
```
We can now visualize the spatial clusters.

```{r bay-plot}
clusterPlot(spe_bay)
```

# Spot deconvolution

We have seen that each spot can contain up to 10 cells in this dataset. Some methods have been developed to deconvolve the gene expression of each spot into different cell types that may make up the spot's composition. Here, we look at one such algorithm, called SPOTlight [@elosua2021spotlight], but many others exist.

```{r prepare_anno}
library(SPOTlight)
library(scRNAseq)

sce <- fetchDataset("zhong-prefrontal-2018", version = "2023-12-22")
colData(sce)
table(sce$cell_types)
```

We want to select only informative genes from the reference, and subsample the cells to have a balanced representation of all the cell types.

```{r preprocess-anno}
library(scran)
# filter low-quality cells
sce <- addPerCellQC(sce)
sce <- sce[, sce$sum > 1000]

# normalization
sce <- logNormCounts(sce)

# hvg selection
dec <- modelGeneVar(sce)
hvg <- getTopHVGs(dec, n = 3000)

# marker genes
colLabels(sce) <- colData(sce)$cell_types
mgs <- scoreMarkers(sce)

# keep only genes informative for cell type identity 
mgs_fil <- lapply(names(mgs), function(i) {
    x <- mgs[[i]]
    # Filter and keep relevant marker genes, those with AUC > 0.8
    x <- x[x$mean.AUC > 0.8, ]
    # Sort the genes from highest to lowest weight
    x <- x[order(x$mean.AUC, decreasing = TRUE), ]
    # Add gene and cluster id to the dataframe
    x$gene <- rownames(x)
    x$cluster <- i
    data.frame(x)
})
mgs_df <- do.call(rbind, mgs_fil)
head(mgs_df)
```

For computational reason, we select 5 cells per cell type, but in real analyses 100 cells per cell types may be used.

```{r cell-sel}
# split cell indices by identity
idx <- split(seq(ncol(sce)), sce$cell_types)

# downsample to at most 5 per identity & subset
set.seed(1035)
n_cells <- 5
cs_keep <- lapply(idx, function(i) {
    n <- length(i)
    if (n < n_cells)
        n_cells <- n
    sample(i, n_cells)
})
sce <- sce[, unlist(cs_keep)]
```

We are now ready to run the spot deconvolution.

```{r spotlight}
# the reference uses gene symbol as row names
rownames(spe) <- rowData(spe)$gene_name

res <- SPOTlight(
    x = sce,
    y = spe,
    groups = as.character(sce$cell_types),
    mgs = mgs_df,
    hvg = hvg,
    weight_id = "mean.AUC",
    group_id = "cluster",
    gene_id = "gene")

# extract results
mod <- res$NMF
```

We can visualize the results in several ways, but the most popular is the so-called "scatter pie", which represents the proportion of cell types in each spot as a pie chart.

```{r vis-spot}
# SPOTlight needs unique sample_id names
imgData(spe)$sample_id[1] <- "sample_151673_lr"

mat <- res$mat
ct <- colnames(mat)
mat[mat < 0.1] <- 0

# Define color palette
# (here we use 'paletteMartin' from the 'colorBlindness' package)
paletteMartin <- c(
    "#000000", "#004949", "#009292", "#ff6db6", "#ffb6db", 
    "#490092", "#006ddb", "#b66dff", "#6db6ff", "#b6dbff", 
    "#920000", "#924900", "#db6d00", "#24ff24", "#ffff6d")

pal <- colorRampPalette(paletteMartin)(length(ct))
names(pal) <- ct

plotSpatialScatterpie(
    x = spe,
    y = mat,
    cell_types = colnames(mat),
    img = FALSE,
    scatterpie_alpha = 1,
    pie_scale = 0.4) +
    scale_fill_manual(
        values = pal,
        breaks = names(pal))
```

# Working with Imaging-based data

We can download and visualize an example CosMX data, using the `SFEData` Bioconductor package.

```{r}
library(SFEData)
sfe <- HeNSCLCData()
sfe
```

*Exercise*: familiarize yourself with the SpatialFeatureExperiment class, verify that it extends SpatialExperiment.

```{r}
library(Voyager)

plotCellBin2D(sfe, hex = TRUE)
fov1 <- sfe[,1:2408]
plotGeometry(fov1, MARGIN = 2L, type = "cellSeg")
```

*Exercise*: identify and visualize highly-variable genes (using methods seen above).

*Exercise*: identify and visualize cell clusters (using methods seen in the single-cell RNA-seq lab).

*Exercise*: go through the [Voyager vignette](https://pachterlab.github.io/voyager/articles/vig4_cosmx.html) to compute quality control metrics and identify spatial patterns of expression.

# Session information

It is good practice to always include a list of the software versions that were used to perform a given analysis, for reproducibility and trouble-shooting purposes. One way of achieving this is via the `sessionInfo()` function.

```{r}
sessionInfo()
```

# References

